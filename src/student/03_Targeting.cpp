/*
 * ═══════════════════════════════════════════════════════════════════════
 *  PLANETARY DEFENSE COMMAND - Targeting Module
 * ═══════════════════════════════════════════════════════════════════════
 *  Αρχείο: 03_Targeting.cpp
 *  Θεωρία: Συναρτήσεις, Παράμετροι, Μαθηματικά
 * ═══════════════════════════════════════════════════════════════════════
 *  
 *  ΣΥΝΑΡΤΗΣΕΙΣ:
 *  Μια συνάρτηση είναι ένα "κουτί" που:
 *    - Παίρνει εισόδους (παράμετροι)
 *    - Κάνει υπολογισμούς
 *    - Επιστρέφει αποτέλεσμα (return)
 *
 *  ΣΥΝΤΑΞΗ:
 *    τύπος_επιστροφής όνομα(τύπος παράμετρος1, τύπος παράμετρος2) {
 *        // κώδικας
 *        return αποτέλεσμα;
 *    }
 *
 *  ΠΑΡΑΔΕΙΓΜΑ:
 *    int add(int a, int b) {
 *        return a + b;
 *    }
 *
 * ═══════════════════════════════════════════════════════════════════════
 */

#include <iostream>
#include <cmath>  // Για sqrt(), pow(), abs()

using namespace std;

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 3.1: ΒΑΣΙΚΗ ΣΥΓΚΡΙΣΗ
// ═══════════════════════════════════════════════════════════════════════

bool isEnemyInRange(double distance, double range) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 3.1: ΕΛΕΓΧΟΣ ΑΠΟΣΤΑΣΗΣ                                  │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Επέστρεψε true αν ο εχθρός είναι στην εμβέλεια.                │
    // │  distance <= range → true                                       │
    // │                                                                 │
    // │  ΣΩΣΤΗ ΛΥΣΗ (ήδη υλοποιημένη):                                  │
    // └─────────────────────────────────────────────────────────────────┘
    
    if (distance <= range) {
        return true;
    }
    return false;
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 3.2: ΑΠΛΟΣ ΠΟΛΛΑΠΛΑΣΙΑΣΜΟΣ
// ═══════════════════════════════════════════════════════════════════════

int calculateDamage(int baseDamage, int level) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 3.2: ΥΠΟΛΟΓΙΣΜΟΣ ΖΗΜΙΑΣ                                 │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Ζημιά = baseDamage * level                                     │
    // │                                                                 │
    // │  ΣΩΣΤΗ ΛΥΣΗ (ήδη υλοποιημένη):                                  │
    // └─────────────────────────────────────────────────────────────────┘
    
    int damage = baseDamage * level;
    return damage;
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 3.3: ΤΥΠΟΣ ΜΕ ΠΟΛΛΕΣ ΜΕΤΑΒΛΗΤΕΣ
// ═══════════════════════════════════════════════════════════════════════

int calculateTotalDamage(int baseDamage, int level, int critMultiplier) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 3.3: ΣΥΝΘΕΤΟΣ ΤΥΠΟΣ                                     │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Υπολόγισε: damage = baseDamage * level * critMultiplier        │
    // │                                                                 │
    // │  ΠΑΡΑΔΕΙΓΜΑ:                                                    │
    // │    baseDamage = 10, level = 2, critMultiplier = 3               │
    // │    Αποτέλεσμα: 10 * 2 * 3 = 60                                  │
    // └─────────────────────────────────────────────────────────────────┘
    
    // TODO: Υπολόγισε και επέστρεψε τη συνολική ζημιά
    
    return 0;  // Προσωρινά
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 3.4: ΔΙΑΙΡΕΣΗ ΚΑΙ ΥΠΟΛΟΙΠΟ
// ═══════════════════════════════════════════════════════════════════════

int calculateFireRate(int baseSpeed, int upgradeLevel) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 3.4: ΔΙΑΙΡΕΣΗ                                           │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Ο ρυθμός βολής βελτιώνεται με τα upgrades:                     │
    // │  fireRate = baseSpeed / (upgradeLevel + 1)                      │
    // │                                                                 │
    // │  ΠΡΟΣΟΧΗ: Ακέραια διαίρεση! 7 / 2 = 3 (όχι 3.5)                 │
    // │                                                                 │
    // │  ΠΑΡΑΔΕΙΓΜΑ:                                                    │
    // │    baseSpeed = 100, upgradeLevel = 1                            │
    // │    fireRate = 100 / (1 + 1) = 100 / 2 = 50                      │
    // └─────────────────────────────────────────────────────────────────┘
    
    // TODO: Υπολόγισε το fire rate
    // HINT: return baseSpeed / (upgradeLevel + 1);
    
    return 100;  // Προσωρινά
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 3.5: ΑΠΟΣΤΑΣΗ ΣΤΟ GRID (Πυθαγόρειο Θεώρημα)
// ═══════════════════════════════════════════════════════════════════════

double calculateGridDistance(int x1, int y1, int x2, int y2) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 3.5: ΠΥΘΑΓΟΡΕΙΟ ΘΕΩΡΗΜΑ                                 │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Υπολόγισε την απόσταση μεταξύ δύο σημείων:                     │
    // │                                                                 │
    // │  ΤΥΠΟΣ: distance = √((x2-x1)² + (y2-y1)²)                       │
    // │                                                                 │
    // │  ΒΗΜΑΤΑ:                                                        │
    // │  1. Υπολόγισε dx = x2 - x1                                      │
    // │  2. Υπολόγισε dy = y2 - y1                                      │
    // │  3. Επέστρεψε sqrt(dx*dx + dy*dy)                               │
    // │                                                                 │
    // │  HINT: Χρησιμοποίησε sqrt() από <cmath>                         │
    // └─────────────────────────────────────────────────────────────────┘
    
    // TODO: Υλοποίησε τον υπολογισμό απόστασης
    
    return 0.0;  // Προσωρινά
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 3.6: ΕΠΙΛΟΓΗ ΣΤΟΧΟΥ (Κοντινότερος Εχθρός)
// ═══════════════════════════════════════════════════════════════════════

int selectTarget(double enemy1Dist, double enemy2Dist, double enemy3Dist) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 3.6: ΕΥΡΕΣΗ ΕΛΑΧΙΣΤΟΥ                                   │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Βρες ποιος εχθρός είναι πιο κοντά και επέστρεψε τον αριθμό του:│
    // │  - Αν ο 1ος είναι κοντύτερα → return 1                          │
    // │  - Αν ο 2ος είναι κοντύτερα → return 2                          │
    // │  - Αν ο 3ος είναι κοντύτερα → return 3                          │
    // │                                                                 │
    // │  HINT: Σύγκρινε τις αποστάσεις με if/else if/else               │
    // └─────────────────────────────────────────────────────────────────┘
    
    // TODO: Βρες τον κοντινότερο εχθρό
    
    return 1;  // Προσωρινά επιστρέφει τον πρώτο
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 3.7: ΖΗΜΙΑ ΜΕ BONUS
// ═══════════════════════════════════════════════════════════════════════

int calculateBonusDamage(int baseDamage, int enemyHealth, int towerLevel) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 3.7: ΣΥΝΘΕΤΟΣ ΥΠΟΛΟΓΙΣΜΟΣ                               │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Υπολόγισε ζημιά με bonus για αδύναμους εχθρούς:                │
    // │                                                                 │
    // │  1. Βασική ζημιά = baseDamage * towerLevel                      │
    // │  2. Αν enemyHealth < 50, πρόσθεσε bonus 20%                     │
    // │     (δηλαδή: ζημιά = ζημιά + ζημιά * 20 / 100)                  │
    // │                                                                 │
    // │  HINT: Χρησιμοποίησε int για να αποφύγεις δεκαδικά              │
    // └─────────────────────────────────────────────────────────────────┘
    
    // TODO: Υλοποίησε τον υπολογισμό
    
    return baseDamage;  // Προσωρινά
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 3.8: ΠΡΟΒΛΕΨΗ ΘΕΣΗΣ ΕΧΘΡΟΥ
// ═══════════════════════════════════════════════════════════════════════

double predictEnemyPosition(double currentX, double speed, double time) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 3.8: ΚΙΝΗΜΑΤΙΚΗ (Φυσική!)                               │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Πρόβλεψε πού θα είναι ο εχθρός μετά από χρόνο time:            │
    // │                                                                 │
    // │  ΤΥΠΟΣ: θέση = αρχική_θέση + ταχύτητα * χρόνος                  │
    // │         futureX = currentX + speed * time                       │
    // │                                                                 │
    // │  ΠΑΡΑΔΕΙΓΜΑ:                                                    │
    // │    currentX = 10, speed = 2, time = 5                           │
    // │    futureX = 10 + 2 * 5 = 20                                    │
    // └─────────────────────────────────────────────────────────────────┘
    
    // TODO: Υπολόγισε τη μελλοντική θέση
    
    return currentX;  // Προσωρινά
}

/*
 * ═══════════════════════════════════════════════════════════════════════
 *  PLANETARY DEFENSE COMMAND - Radar Module
 * ═══════════════════════════════════════════════════════════════════════
 *  Αρχείο: 04_Radar.cpp
 *  Θεωρία: Ενότητα 3 - Βρόχοι (Loops)
 * ═══════════════════════════════════════════════════════════════════════
 *  
 *  FOR LOOP:
 *    for (αρχική_τιμή; συνθήκη; αύξηση) {
 *        // κώδικας που επαναλαμβάνεται
 *    }
 *    
 *    ΠΑΡΑΔΕΙΓΜΑ:
 *    for (int i = 0; i < 5; i++) {
 *        cout << i << endl;  // Τυπώνει: 0, 1, 2, 3, 4
 *    }
 *
 *  WHILE LOOP:
 *    while (συνθήκη) {
 *        // κώδικας που επαναλαμβάνεται όσο η συνθήκη είναι true
 *    }
 *
 *  DO-WHILE LOOP:
 *    do {
 *        // εκτελείται τουλάχιστον 1 φορά
 *    } while (συνθήκη);
 *
 *  BREAK: Σταματάει τον βρόχο αμέσως
 *  CONTINUE: Πηγαίνει στην επόμενη επανάληψη
 *
 * ═══════════════════════════════════════════════════════════════════════
 */

#include <iostream>
#include <vector>

using namespace std;

// Δομή για έναν εχθρό στο Radar
// (χρησιμοποιεί RadarEnemy αντί για Enemy για να μην μπερδεύεται με άλλες δομές)
struct RadarEnemy {
    double distance;   // Απόσταση από τη βάση
    int health;        // Ζωή
    bool isFlying;     // Αν πετάει
};

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 4.1: ΒΑΣΙΚΟ FOR LOOP - Μέτρηση Εχθρών
// ═══════════════════════════════════════════════════════════════════════

int countAllEnemies(vector<RadarEnemy> enemies) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 4.1: ΒΑΣΙΚΟ FOR LOOP                                    │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Μέτρα πόσοι εχθροί υπάρχουν στη λίστα.                         │
    // │                                                                 │
    // │  HINT: Η απάντηση είναι απλά enemies.size()!                    │
    // │  Αλλά για εξάσκηση, μέτρα με loop:                              │
    // │                                                                 │
    // │  int count = 0;                                                 │
    // │  for (int i = 0; i < enemies.size(); i++) {                     │
    // │      count++;                                                   │
    // │  }                                                              │
    // │  return count;                                                  │
    // └─────────────────────────────────────────────────────────────────┘
    
    // ΣΩΣΤΗ ΛΥΣΗ:
    int count = 0;
    for (int i = 0; i < enemies.size(); i++) {
        count++;
    }
    return count;
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 4.2: FOR LOOP ΜΕ ΣΥΝΘΗΚΗ - Κοντινοί Εχθροί
// ═══════════════════════════════════════════════════════════════════════

int countCloseEnemies(vector<RadarEnemy> enemies, double maxDistance) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 4.2: FOR LOOP ΜΕ IF                                     │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Μέτρα πόσοι εχθροί είναι σε απόσταση < maxDistance.            │
    // │                                                                 │
    // │  ΒΗΜΑΤΑ:                                                        │
    // │  1. Ξεκίνα με count = 0                                         │
    // │  2. Για κάθε εχθρό στη λίστα:                                   │
    // │     - Αν enemies[i].distance < maxDistance                      │
    // │     - Αύξησε το count                                           │
    // │  3. Επέστρεψε το count                                          │
    // │                                                                 │
    // │  HINT: Μέσα στο for, πρόσθεσε: if (enemies[i].distance < maxDistance) count++;│
    // └─────────────────────────────────────────────────────────────────┘
    
    int count = 0;
    
    // TODO: Γράψε το for loop με τη συνθήκη
    
    return count;
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 4.3: ΑΘΡΟΙΣΜΑ - Συνολική Ζωή Εχθρών
// ═══════════════════════════════════════════════════════════════════════

int getTotalEnemyHealth(vector<RadarEnemy> enemies) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 4.3: ΑΘΡΟΙΣΜΑ ΣΕ LOOP                                   │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Υπολόγισε τη συνολική ζωή όλων των εχθρών.                     │
    // │                                                                 │
    // │  PATTERN:                                                       │
    // │  int total = 0;                                                 │
    // │  for (...) {                                                    │
    // │      total = total + enemies[i].health;  // ή total += ...      │
    // │  }                                                              │
    // └─────────────────────────────────────────────────────────────────┘
    
    int total = 0;
    
    // TODO: Πρόσθεσε τη ζωή κάθε εχθρού στο total
    
    return total;
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 4.4: ΕΥΡΕΣΗ ΕΛΑΧΙΣΤΟΥ - Κοντινότερος Εχθρός
// ═══════════════════════════════════════════════════════════════════════

double findClosestEnemy(vector<RadarEnemy> enemies) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 4.4: ΕΥΡΕΣΗ ΕΛΑΧΙΣΤΟΥ                                   │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Βρες την απόσταση του κοντινότερου εχθρού.                     │
    // │                                                                 │
    // │  PATTERN:                                                       │
    // │  double minDist = 9999;  // Ξεκίνα με πολύ μεγάλο               │
    // │  for (...) {                                                    │
    // │      if (enemies[i].distance < minDist) {                       │
    // │          minDist = enemies[i].distance;                         │
    // │      }                                                          │
    // │  }                                                              │
    // └─────────────────────────────────────────────────────────────────┘
    
    if (enemies.size() == 0) return -1;  // Κανένας εχθρός
    
    double minDist = 9999;
    
    // TODO: Βρες τον κοντινότερο
    
    return minDist;
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 4.5: ΕΥΡΕΣΗ ΜΕΓΙΣΤΟΥ - Ισχυρότερος Εχθρός
// ═══════════════════════════════════════════════════════════════════════

int findStrongestEnemy(vector<RadarEnemy> enemies) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 4.5: ΕΥΡΕΣΗ ΜΕΓΙΣΤΟΥ                                    │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Βρες τη μέγιστη ζωή μεταξύ όλων των εχθρών.                    │
    // │                                                                 │
    // │  PATTERN:                                                       │
    // │  int maxHealth = 0;  // Ξεκίνα με 0                             │
    // │  for (...) {                                                    │
    // │      if (enemies[i].health > maxHealth) {                       │
    // │          maxHealth = enemies[i].health;                         │
    // │      }                                                          │
    // │  }                                                              │
    // └─────────────────────────────────────────────────────────────────┘
    
    int maxHealth = 0;
    
    // TODO: Βρες τη μέγιστη ζωή
    
    return maxHealth;
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 4.6: ΜΕΤΡΗΣΗ ΜΕ ΠΟΛΛΑΠΛΕΣ ΣΥΝΘΗΚΕΣ
// ═══════════════════════════════════════════════════════════════════════

int countFlyingEnemiesInRange(vector<RadarEnemy> enemies, double range) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 4.6: LOOP ΜΕ && (AND)                                   │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Μέτρα τους εχθρούς που:                                        │
    // │  - Πετάνε (isFlying == true)                                    │
    // │  - ΚΑΙ είναι στην εμβέλεια (distance <= range)                  │
    // │                                                                 │
    // │  HINT: if (enemies[i].isFlying && enemies[i].distance <= range) │
    // └─────────────────────────────────────────────────────────────────┘
    
    int count = 0;
    
    // TODO: Μέτρα με δύο συνθήκες
    
    return count;
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 4.7: WHILE LOOP - Αναμονή για Εχθρούς
// ═══════════════════════════════════════════════════════════════════════

int simulateWaiting(int startWave, int targetEnemies) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 4.7: WHILE LOOP                                         │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Υπολόγισε πόσα waves χρειάζονται για να εμφανιστούν            │
    // │  τουλάχιστον targetEnemies εχθροί.                              │
    // │                                                                 │
    // │  Κάθε wave φέρνει: wave * 2 εχθρούς                             │
    // │  (Wave 1 → 2, Wave 2 → 4, Wave 3 → 6, ...)                      │
    // │                                                                 │
    // │  PATTERN:                                                       │
    // │  int wave = startWave;                                          │
    // │  int totalEnemies = 0;                                          │
    // │  while (totalEnemies < targetEnemies) {                         │
    // │      totalEnemies += wave * 2;                                  │
    // │      wave++;                                                    │
    // │  }                                                              │
    // │  return wave - startWave;  // Πόσα waves πέρασαν                │
    // └─────────────────────────────────────────────────────────────────┘
    
    // TODO: Υλοποίησε με while loop
    
    return 1;  // Προσωρινά
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 4.8: BREAK - Πρώτος Επικίνδυνος Εχθρός
// ═══════════════════════════════════════════════════════════════════════

int findFirstDangerousEnemy(vector<RadarEnemy> enemies, int dangerThreshold) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 4.8: BREAK                                              │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Βρες τον ΠΡΩΤΟ εχθρό με ζωή >= dangerThreshold.                │
    // │  Επέστρεψε τον δείκτη του (i).                                  │
    // │  Αν δεν υπάρχει, επέστρεψε -1.                                  │
    // │                                                                 │
    // │  PATTERN:                                                       │
    // │  for (int i = 0; i < enemies.size(); i++) {                     │
    // │      if (enemies[i].health >= dangerThreshold) {                │
    // │          return i;  // ή break; μετά αποθήκευση του i           │
    // │      }                                                          │
    // │  }                                                              │
    // │  return -1;                                                     │
    // └─────────────────────────────────────────────────────────────────┘
    
    // TODO: Βρες τον πρώτο επικίνδυνο
    
    return -1;  // Προσωρινά
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 4.9: ΑΝΤΙΣΤΡΟΦΟ LOOP - Countdown
// ═══════════════════════════════════════════════════════════════════════

int countdownSum(int start) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 4.9: ΑΝΤΙΣΤΡΟΦΟ FOR LOOP                                │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Υπολόγισε το άθροισμα: start + (start-1) + ... + 1             │
    // │                                                                 │
    // │  ΠΑΡΑΔΕΙΓΜΑ: start = 5                                          │
    // │  5 + 4 + 3 + 2 + 1 = 15                                         │
    // │                                                                 │
    // │  PATTERN:                                                       │
    // │  for (int i = start; i >= 1; i--) {                             │
    // │      // i μειώνεται αντί να αυξάνεται!                          │
    // │  }                                                              │
    // └─────────────────────────────────────────────────────────────────┘
    
    int sum = 0;
    
    // TODO: Άθροισε από start μέχρι 1
    
    return sum;
}

// ═══════════════════════════════════════════════════════════════════════
// ΑΣΚΗΣΗ 4.10: NESTED LOOPS - Grid Scan
// ═══════════════════════════════════════════════════════════════════════

int countGridCells(int width, int height) {
    // ┌─────────────────────────────────────────────────────────────────┐
    // │  ΑΣΚΗΣΗ 4.10: ΕΜΦΩΛΕΥΜΕΝΑ LOOPS (BONUS)                         │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  Μέτρα πόσα κελιά έχει ένα grid width x height.                 │
    // │  (Η απάντηση είναι width * height, αλλά υπολόγισέ το με loops!) │
    // │                                                                 │
    // │  PATTERN:                                                       │
    // │  for (int y = 0; y < height; y++) {                             │
    // │      for (int x = 0; x < width; x++) {                          │
    // │          count++;                                               │
    // │      }                                                          │
    // │  }                                                              │
    // └─────────────────────────────────────────────────────────────────┘
    
    int count = 0;
    
    // TODO: Διπλό loop για grid
    
    return count;
}
